"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./contexts/PlayerContext.jsx":
/*!************************************!*\
  !*** ./contexts/PlayerContext.jsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PlayerProvider\": function() { return /* binding */ PlayerProvider; },\n/* harmony export */   \"usePlayer\": function() { return /* binding */ usePlayer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s2, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s2 = _i.next()).done); _n = true){\n            _arr.push(_s2.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar _this = undefined;\n\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\nvar playerContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)();\nvar usePlayer = function() {\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(playerContext);\n};\n_s(usePlayer, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar PlayerProvider = function(param) {\n    var children = param.children;\n    _s1();\n    var ROWS_COUNT = 3;\n    var EQUATION_LENGTH = 3;\n    var ref9 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), currentGuess = ref9[0], setCurrentGuess = ref9[1];\n    var ref1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0), currentIndex = ref1[0], setCurrentIndex = ref1[1];\n    var ref2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Array(ROWS_COUNT).fill(null)), guesses = ref2[0], setGuesses = ref2[1];\n    var ref3 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), gameover = ref3[0], setGameover = ref3[1];\n    var ref4 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), win = ref4[0], setWin = ref4[1];\n    var ref5 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), equation = ref5[0], setEquation = ref5[1];\n    var ref6 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), error = ref6[0], setError = ref6[1];\n    var ref7 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), gameoverModal = ref7[0], setGameoverModal = ref7[1];\n    var ref8 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Array(ROWS_COUNT).fill(null)), guessedResult = ref8[0], setGuessedResult = ref8[1];\n    var handleInput = function(e) {\n        var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n        var key = e.key || value;\n        if (gameover) return;\n        var eqFilter = /^[0-9+\\-*/=]|(Backspace|Enter)+$/;\n        var temp_operators = [\n            \"+\",\n            \"-\",\n            \"*\",\n            \"/\"\n        ];\n        if (!eqFilter.test(key)) {\n            return;\n        }\n        if (key === \"Enter\") {\n            if (currentGuess.length !== EQUATION_LENGTH) {\n                setError(\"You need to fill up the squares.\");\n                return;\n            }\n            /*if (\n        !currentGuess.includes(\"+\") &&\n        !currentGuess.includes(\"-\") &&\n        !currentGuess.includes(\"*\") &&\n        !currentGuess.includes(\"/\")\n      ) {\n        setError(\"The equation needs to include at least one operator.\");\n        return;\n      }*/ if (!currentGuess.includes(\"=\")) {\n                setError(\"The equation needs to include '='.\");\n                return;\n            }\n            if (currentGuess[0] === \"/\" || currentGuess[0] === \"*\") {\n                setError(\"Invalid Equation.\");\n                return;\n            }\n            if (currentGuess.split(\"=\").length - 1 !== 1) {\n                setError(\"There are multiple '=' in the equation.\");\n                return;\n            }\n            var ref = _slicedToArray(currentGuess.split(\"=\"), 2), LHS = ref[0], RHS = ref[1];\n            LHS = formatEquation(LHS);\n            RHS = formatEquation(RHS);\n            for(var i = 0; i < LHS.length; i++){\n                if (LHS[i].length > 1) {\n                    if (i === LHS.length - 1) {\n                        if (temp_operators.includes(LHS[i][0])) {\n                            setError(\"Invalid Equation.\");\n                            return;\n                        }\n                    }\n                    if (temp_operators.includes(LHS[i][0]) && temp_operators.includes(LHS[i][1])) {\n                        setError(\"Invalid Equation.\");\n                        return;\n                    }\n                }\n            }\n            for(var i1 = 0; i1 < RHS.length; i1++){\n                if (RHS[i1].length > 1) {\n                    if (i1 === RHS.length - 1) {\n                        if (temp_operators.includes(RHS[i1][0])) {\n                            setError(\"Invalid Equation.\");\n                            return;\n                        }\n                    }\n                    if (temp_operators.includes(RHS[i1][0]) && temp_operators.includes(RHS[i1][1])) {\n                        setError(\"Invalid Equation.\");\n                        return;\n                    }\n                }\n            }\n            if (calculateArray(LHS) !== calculateArray(RHS)) {\n                setError(\"Left side in not equal to the right side.\");\n                return;\n            }\n            var temp_guess = _toConsumableArray(guesses);\n            temp_guess[currentIndex] = currentGuess;\n            setGuesses(temp_guess);\n            if (currentGuess === equation) {\n                setGameover(true);\n                setWin(true);\n            } else if (currentIndex === ROWS_COUNT - 1) {\n                setGameover(true);\n            }\n            setCurrentIndex(function(prev) {\n                return prev + 1;\n            });\n            setCurrentGuess(\"\");\n            return;\n        }\n        if (key === \"Backspace\") {\n            setCurrentGuess(function(prev) {\n                return prev.slice(0, -1);\n            });\n            return;\n        }\n        if (currentGuess.length !== EQUATION_LENGTH) {\n            setCurrentGuess(function(prev) {\n                return prev + key;\n            });\n        }\n    };\n    var resetEverything = function() {\n        setCurrentGuess(\"\");\n        setCurrentIndex(0);\n        setGuesses(Array(ROWS_COUNT).fill(null));\n        setGameover(false);\n        setWin(false);\n        setEquation(\"\");\n        setError(\"\");\n        setGameoverModal(false);\n        setGuessedResult(Array(ROWS_COUNT).fill(null));\n    };\n    var generateEquation = function(length) {\n        var equationLength = length;\n        var maxOperatorCount = Math.floor(equationLength / 2 - 1);\n        var minOperatorCount = 0;\n        var possibleOperators = [\n            \"+\",\n            \"-\",\n            \"/\",\n            \"*\"\n        ];\n        var possibleNumbers = \"0123456789\";\n        var operatorsToUse = [];\n        var numbersToUse = [];\n        var randomOperatorCount = getRandomInt(minOperatorCount, maxOperatorCount);\n        for(var i = 0; i < randomOperatorCount; i++){\n            operatorsToUse.push(possibleOperators[getRandomInt(0, possibleOperators.length - 1)]);\n        }\n        if (operatorsToUse[0] !== \"-\" && operatorsToUse.length === maxOperatorCount) {\n            operatorsToUse.splice(-1, 1);\n        }\n        var LHSNumberCount = maxOperatorCount > 1 && operatorsToUse.length === maxOperatorCount ? operatorsToUse.length : getRandomInt(operatorsToUse.length + 1, equationLength - operatorsToUse.length - 2);\n        for(var i2 = 0; i2 < LHSNumberCount; i2++){\n            numbersToUse.push(possibleNumbers[getRandomInt(0, possibleNumbers.length - 1)]);\n        }\n        var LHSequationLength = operatorsToUse.length + LHSNumberCount;\n        var LHSequation = Array(LHSequationLength);\n        for(var i3 = 0; i3 < LHSequationLength; i3++){\n            if (operatorsToUse.length === 0) break;\n            if (operatorsToUse.length === maxOperatorCount) {\n                LHSequation[i3] = operatorsToUse[0];\n                operatorsToUse.splice(0, 1);\n                continue;\n            }\n            if (i3 !== 0 && i3 !== LHSequationLength - 1) {\n                if (!possibleOperators.includes(LHSequation[i3 - 1])) {\n                    LHSequation[i3] = operatorsToUse[0];\n                    operatorsToUse.splice(0, 1);\n                }\n            }\n        }\n        for(var j = 0; j < LHSequationLength; j++){\n            if (numbersToUse.length === 0) break;\n            if (LHSequation[j] === undefined) {\n                LHSequation[j] = numbersToUse[0];\n                numbersToUse.splice(0, 1);\n            }\n        }\n        var eqString = LHSequation.join(\"\");\n        var formattedEqArray = formatEquation(eqString);\n        for(var i4 = 0; i4 < formattedEqArray.length; i4++){\n            if (formattedEqArray[i4].length > 1 && formattedEqArray[i4][0] === \"0\") {\n                var temp_number = \"\";\n                for(var j1 = 0; j1 < formattedEqArray[i4].length; j1++){\n                    temp_number += getRandomInt(1, 9).toString();\n                }\n                formattedEqArray.splice(i4, 1, temp_number);\n            }\n        }\n        var RHSAnswer = calculateArray(formatEquation(eqString));\n        if (!RHSAnswer) return generateEquation(length);\n        var finalEquation = eqString + \"=\" + RHSAnswer;\n        if (finalEquation.length !== equationLength) return generateEquation(length);\n        return finalEquation;\n    };\n    var formatEquation = function(expression) {\n        var copy = expression;\n        expression = expression.replace(/[0-9]+/g, \"#\");\n        var numbers = copy.split(/[^0-9\\.]+/).filter(function(n) {\n            return n;\n        });\n        var operators = expression.split(\"#\").filter(function(n) {\n            return n;\n        });\n        var result = [];\n        for(var i = 0; i < numbers.length; i++){\n            if (operators.length === numbers.length) {\n                result.push(operators[i]);\n                result.push(numbers[i]);\n            } else {\n                result.push(numbers[i]);\n                if (i < operators.length) result.push(operators[i]);\n            }\n        }\n        return result;\n    };\n    var calculateArray = function(arrayEquation) {\n        var result;\n        var temp_array = _toConsumableArray(arrayEquation);\n        var divide = temp_array.indexOf(\"/\");\n        var multiply = temp_array.indexOf(\"*\");\n        var substract = temp_array.indexOf(\"-\");\n        var add = temp_array.indexOf(\"+\");\n        if (temp_array.length === 1) return parseInt(temp_array[0]);\n        if (add === 0) {\n            temp_array.splice(add, 1);\n        }\n        if (substract === 0) {\n            if (temp_array[substract + 1] === \"0\") {\n                temp_array.splice(substract + 1, 1, getRandomInt(1, 9).toString());\n            }\n            result = parseInt(temp_array[substract] + temp_array[substract + 1]);\n            temp_array.splice(substract, 2, result);\n        } else if (divide > 0) {\n            if (parseInt(temp_array[divide + 1]) === 0) return false;\n            if (parseInt(temp_array[divide - 1]) % parseInt(temp_array[divide + 1]) !== 0) return false;\n            result = parseInt(temp_array[divide - 1]) / parseInt(temp_array[divide + 1]);\n            temp_array.splice(divide - 1, 3, result);\n        } else if (multiply > 0) {\n            result = parseInt(temp_array[multiply - 1]) * parseInt(temp_array[multiply + 1]);\n            temp_array.splice(multiply - 1, 3, result);\n        } else if (add > 0) {\n            result = parseInt(temp_array[add - 1]) + parseInt(temp_array[add + 1]);\n            temp_array.splice(add - 1, 3, result);\n        } else if (substract > 0) {\n            result = parseInt(temp_array[substract - 1]) - parseInt(temp_array[substract + 1]);\n            temp_array.splice(substract - 1, 3, result);\n        }\n        return calculateArray(temp_array);\n    };\n    var getRandomInt = function(min, max) {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min + 1) + min); /* for min and max inclusive */ \n    };\n    var values = {\n        generateEquation: generateEquation,\n        ROWS_COUNT: ROWS_COUNT,\n        EQUATION_LENGTH: EQUATION_LENGTH,\n        currentIndex: currentIndex,\n        currentGuess: currentGuess,\n        handleInput: handleInput,\n        guesses: guesses,\n        equation: equation,\n        setEquation: setEquation,\n        error: error,\n        setError: setError,\n        gameover: gameover,\n        win: win,\n        guessedResult: guessedResult,\n        setGuessedResult: setGuessedResult,\n        gameoverModal: gameoverModal,\n        setGameoverModal: setGameoverModal,\n        resetEverything: resetEverything\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(playerContext.Provider, {\n        value: values,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/lucasklenovich/Documents/GitHub/ngt1/contexts/PlayerContext.jsx\",\n        lineNumber: 323,\n        columnNumber: 5\n    }, _this);\n};\n_s1(PlayerProvider, \"5v9xnvGDx2ysOMyYGYJq6NoNOVk=\");\n_c = PlayerProvider;\n\nvar _c;\n$RefreshReg$(_c, \"PlayerProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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eUMsSUFBSSxDQUFDRixHQUFHLENBQUMsQ0FBQztRQUNyQkMsR0FBRyxHQUFHeEMsSUFBSSxDQUFDQyxLQUFLLENBQUN1QyxHQUFHLENBQUMsQ0FBQztRQUN0QixPQUFPeEMsSUFBSSxDQUFDQyxLQUFLLENBQ2ZELElBQUksQ0FBQzBDLE1BQU0sRUFBRSxHQUFHLENBQUNGLEdBQUcsR0FBR0QsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHQSxHQUFHLENBQ3RDLENBQUMsQ0FBQywrQkFBK0I7S0FDbkM7SUFFRCxJQUFNSSxNQUFNLEdBQUc7UUFDYjlDLGdCQUFnQixFQUFoQkEsZ0JBQWdCO1FBQ2hCekMsVUFBVSxFQUFWQSxVQUFVO1FBQ1ZDLGVBQWUsRUFBZkEsZUFBZTtRQUNmRyxZQUFZLEVBQVpBLFlBQVk7UUFDWkYsWUFBWSxFQUFaQSxZQUFZO1FBQ1pvQixXQUFXLEVBQVhBLFdBQVc7UUFDWGQsT0FBTyxFQUFQQSxPQUFPO1FBQ1BNLFFBQVEsRUFBUkEsUUFBUTtRQUNSQyxXQUFXLEVBQVhBLFdBQVc7UUFDWEMsS0FBSyxFQUFMQSxLQUFLO1FBQ0xDLFFBQVEsRUFBUkEsUUFBUTtRQUNSUCxRQUFRLEVBQVJBLFFBQVE7UUFDUkUsR0FBRyxFQUFIQSxHQUFHO1FBQ0hRLGFBQWEsRUFBYkEsYUFBYTtRQUNiQyxnQkFBZ0IsRUFBaEJBLGdCQUFnQjtRQUNoQkgsYUFBYSxFQUFiQSxhQUFhO1FBQ2JDLGdCQUFnQixFQUFoQkEsZ0JBQWdCO1FBQ2hCcUIsZUFBZSxFQUFmQSxlQUFlO0tBQ2hCO0lBQ0QscUJBQ0UsOERBQUM1QyxhQUFhLENBQUM0RixRQUFRO1FBQUNoRSxLQUFLLEVBQUUrRCxNQUFNO2tCQUFHeEYsUUFBUTs7Ozs7YUFBMEIsQ0FDMUU7Q0FDSDtJQTVUS0QsY0FBYztBQUFkQSxLQUFBQSxjQUFjO0FBOFRpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb250ZXh0cy9QbGF5ZXJDb250ZXh0LmpzeD8xNWIxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5cbmNvbnN0IHBsYXllckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KCk7XG5cbmNvbnN0IHVzZVBsYXllciA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQocGxheWVyQ29udGV4dCk7XG59O1xuXG5jb25zdCBQbGF5ZXJQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgUk9XU19DT1VOVCA9IDM7XG4gIGNvbnN0IEVRVUFUSU9OX0xFTkdUSCA9IDM7XG4gIGNvbnN0IFtjdXJyZW50R3Vlc3MsIHNldEN1cnJlbnRHdWVzc10gPSB1c2VTdGF0ZShcIlwiKTtcbiAgY29uc3QgW2N1cnJlbnRJbmRleCwgc2V0Q3VycmVudEluZGV4XSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbZ3Vlc3Nlcywgc2V0R3Vlc3Nlc10gPSB1c2VTdGF0ZShBcnJheShST1dTX0NPVU5UKS5maWxsKG51bGwpKTtcbiAgY29uc3QgW2dhbWVvdmVyLCBzZXRHYW1lb3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFt3aW4sIHNldFdpbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcXVhdGlvbiwgc2V0RXF1YXRpb25dID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtnYW1lb3Zlck1vZGFsLCBzZXRHYW1lb3Zlck1vZGFsXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2d1ZXNzZWRSZXN1bHQsIHNldEd1ZXNzZWRSZXN1bHRdID0gdXNlU3RhdGUoXG4gICAgQXJyYXkoUk9XU19DT1VOVCkuZmlsbChudWxsKVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZUlucHV0ID0gKGUsIHZhbHVlID0gXCJcIikgPT4ge1xuICAgIGNvbnN0IGtleSA9IGUua2V5IHx8IHZhbHVlO1xuICAgIGlmIChnYW1lb3ZlcikgcmV0dXJuO1xuICAgIGNvbnN0IGVxRmlsdGVyID0gL15bMC05K1xcLSovPV18KEJhY2tzcGFjZXxFbnRlcikrJC87XG4gICAgY29uc3QgdGVtcF9vcGVyYXRvcnMgPSBbXCIrXCIsIFwiLVwiLCBcIipcIiwgXCIvXCJdO1xuICAgIGlmICghZXFGaWx0ZXIudGVzdChrZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChrZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgaWYgKGN1cnJlbnRHdWVzcy5sZW5ndGggIT09IEVRVUFUSU9OX0xFTkdUSCkge1xuICAgICAgICBzZXRFcnJvcihcIllvdSBuZWVkIHRvIGZpbGwgdXAgdGhlIHNxdWFyZXMuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8qaWYgKFxuICAgICAgICAhY3VycmVudEd1ZXNzLmluY2x1ZGVzKFwiK1wiKSAmJlxuICAgICAgICAhY3VycmVudEd1ZXNzLmluY2x1ZGVzKFwiLVwiKSAmJlxuICAgICAgICAhY3VycmVudEd1ZXNzLmluY2x1ZGVzKFwiKlwiKSAmJlxuICAgICAgICAhY3VycmVudEd1ZXNzLmluY2x1ZGVzKFwiL1wiKVxuICAgICAgKSB7XG4gICAgICAgIHNldEVycm9yKFwiVGhlIGVxdWF0aW9uIG5lZWRzIHRvIGluY2x1ZGUgYXQgbGVhc3Qgb25lIG9wZXJhdG9yLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSovXG4gICAgICBpZiAoIWN1cnJlbnRHdWVzcy5pbmNsdWRlcyhcIj1cIikpIHtcbiAgICAgICAgc2V0RXJyb3IoXCJUaGUgZXF1YXRpb24gbmVlZHMgdG8gaW5jbHVkZSAnPScuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50R3Vlc3NbMF0gPT09IFwiL1wiIHx8IGN1cnJlbnRHdWVzc1swXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgc2V0RXJyb3IoXCJJbnZhbGlkIEVxdWF0aW9uLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudEd1ZXNzLnNwbGl0KFwiPVwiKS5sZW5ndGggLSAxICE9PSAxKSB7XG4gICAgICAgIHNldEVycm9yKFwiVGhlcmUgYXJlIG11bHRpcGxlICc9JyBpbiB0aGUgZXF1YXRpb24uXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgW0xIUywgUkhTXSA9IGN1cnJlbnRHdWVzcy5zcGxpdChcIj1cIik7XG5cbiAgICAgIExIUyA9IGZvcm1hdEVxdWF0aW9uKExIUyk7XG4gICAgICBSSFMgPSBmb3JtYXRFcXVhdGlvbihSSFMpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IExIUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoTEhTW2ldLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gTEhTLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGlmICh0ZW1wX29wZXJhdG9ycy5pbmNsdWRlcyhMSFNbaV1bMF0pKSB7XG4gICAgICAgICAgICAgIHNldEVycm9yKFwiSW52YWxpZCBFcXVhdGlvbi5cIik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGVtcF9vcGVyYXRvcnMuaW5jbHVkZXMoTEhTW2ldWzBdKSAmJlxuICAgICAgICAgICAgdGVtcF9vcGVyYXRvcnMuaW5jbHVkZXMoTEhTW2ldWzFdKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgc2V0RXJyb3IoXCJJbnZhbGlkIEVxdWF0aW9uLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBSSFMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKFJIU1tpXS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgaWYgKGkgPT09IFJIUy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBpZiAodGVtcF9vcGVyYXRvcnMuaW5jbHVkZXMoUkhTW2ldWzBdKSkge1xuICAgICAgICAgICAgICBzZXRFcnJvcihcIkludmFsaWQgRXF1YXRpb24uXCIpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRlbXBfb3BlcmF0b3JzLmluY2x1ZGVzKFJIU1tpXVswXSkgJiZcbiAgICAgICAgICAgIHRlbXBfb3BlcmF0b3JzLmluY2x1ZGVzKFJIU1tpXVsxXSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHNldEVycm9yKFwiSW52YWxpZCBFcXVhdGlvbi5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWxjdWxhdGVBcnJheShMSFMpICE9PSBjYWxjdWxhdGVBcnJheShSSFMpKSB7XG4gICAgICAgIHNldEVycm9yKFwiTGVmdCBzaWRlIGluIG5vdCBlcXVhbCB0byB0aGUgcmlnaHQgc2lkZS5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGVtcF9ndWVzcyA9IFsuLi5ndWVzc2VzXTtcbiAgICAgIHRlbXBfZ3Vlc3NbY3VycmVudEluZGV4XSA9IGN1cnJlbnRHdWVzcztcbiAgICAgIHNldEd1ZXNzZXModGVtcF9ndWVzcyk7XG4gICAgICBpZiAoY3VycmVudEd1ZXNzID09PSBlcXVhdGlvbikge1xuICAgICAgICBzZXRHYW1lb3Zlcih0cnVlKTtcbiAgICAgICAgc2V0V2luKHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50SW5kZXggPT09IFJPV1NfQ09VTlQgLSAxKSB7XG4gICAgICAgIHNldEdhbWVvdmVyKHRydWUpO1xuICAgICAgfVxuICAgICAgc2V0Q3VycmVudEluZGV4KChwcmV2KSA9PiBwcmV2ICsgMSk7XG4gICAgICBzZXRDdXJyZW50R3Vlc3MoXCJcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChrZXkgPT09IFwiQmFja3NwYWNlXCIpIHtcbiAgICAgIHNldEN1cnJlbnRHdWVzcygocHJldikgPT4gcHJldi5zbGljZSgwLCAtMSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudEd1ZXNzLmxlbmd0aCAhPT0gRVFVQVRJT05fTEVOR1RIKSB7XG4gICAgICBzZXRDdXJyZW50R3Vlc3MoKHByZXYpID0+IHByZXYgKyBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByZXNldEV2ZXJ5dGhpbmcgPSAoKSA9PiB7XG4gICAgc2V0Q3VycmVudEd1ZXNzKFwiXCIpO1xuICAgIHNldEN1cnJlbnRJbmRleCgwKTtcbiAgICBzZXRHdWVzc2VzKEFycmF5KFJPV1NfQ09VTlQpLmZpbGwobnVsbCkpO1xuICAgIHNldEdhbWVvdmVyKGZhbHNlKTtcbiAgICBzZXRXaW4oZmFsc2UpO1xuICAgIHNldEVxdWF0aW9uKFwiXCIpO1xuICAgIHNldEVycm9yKFwiXCIpO1xuICAgIHNldEdhbWVvdmVyTW9kYWwoZmFsc2UpO1xuICAgIHNldEd1ZXNzZWRSZXN1bHQoQXJyYXkoUk9XU19DT1VOVCkuZmlsbChudWxsKSk7XG4gIH07XG5cbiAgY29uc3QgZ2VuZXJhdGVFcXVhdGlvbiA9IChsZW5ndGgpID0+IHtcbiAgICBjb25zdCBlcXVhdGlvbkxlbmd0aCA9IGxlbmd0aDtcbiAgICBjb25zdCBtYXhPcGVyYXRvckNvdW50ID0gTWF0aC5mbG9vcihlcXVhdGlvbkxlbmd0aCAvIDIgLSAxKTtcbiAgICBjb25zdCBtaW5PcGVyYXRvckNvdW50ID0gMDtcbiAgICBjb25zdCBwb3NzaWJsZU9wZXJhdG9ycyA9IFtcIitcIiwgXCItXCIsIFwiL1wiLCBcIipcIl07XG4gICAgY29uc3QgcG9zc2libGVOdW1iZXJzID0gXCIwMTIzNDU2Nzg5XCI7XG4gICAgY29uc3Qgb3BlcmF0b3JzVG9Vc2UgPSBbXTtcbiAgICBjb25zdCBudW1iZXJzVG9Vc2UgPSBbXTtcblxuICAgIGNvbnN0IHJhbmRvbU9wZXJhdG9yQ291bnQgPSBnZXRSYW5kb21JbnQoXG4gICAgICBtaW5PcGVyYXRvckNvdW50LFxuICAgICAgbWF4T3BlcmF0b3JDb3VudFxuICAgICk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmRvbU9wZXJhdG9yQ291bnQ7IGkrKykge1xuICAgICAgb3BlcmF0b3JzVG9Vc2UucHVzaChcbiAgICAgICAgcG9zc2libGVPcGVyYXRvcnNbZ2V0UmFuZG9tSW50KDAsIHBvc3NpYmxlT3BlcmF0b3JzLmxlbmd0aCAtIDEpXVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvcGVyYXRvcnNUb1VzZVswXSAhPT0gXCItXCIgJiZcbiAgICAgIG9wZXJhdG9yc1RvVXNlLmxlbmd0aCA9PT0gbWF4T3BlcmF0b3JDb3VudFxuICAgICkge1xuICAgICAgb3BlcmF0b3JzVG9Vc2Uuc3BsaWNlKC0xLCAxKTtcbiAgICB9XG5cbiAgICBjb25zdCBMSFNOdW1iZXJDb3VudCA9XG4gICAgICBtYXhPcGVyYXRvckNvdW50ID4gMSAmJiBvcGVyYXRvcnNUb1VzZS5sZW5ndGggPT09IG1heE9wZXJhdG9yQ291bnRcbiAgICAgICAgPyBvcGVyYXRvcnNUb1VzZS5sZW5ndGhcbiAgICAgICAgOiBnZXRSYW5kb21JbnQoXG4gICAgICAgICAgICBvcGVyYXRvcnNUb1VzZS5sZW5ndGggKyAxLFxuICAgICAgICAgICAgZXF1YXRpb25MZW5ndGggLSBvcGVyYXRvcnNUb1VzZS5sZW5ndGggLSAyXG4gICAgICAgICAgKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTEhTTnVtYmVyQ291bnQ7IGkrKykge1xuICAgICAgbnVtYmVyc1RvVXNlLnB1c2goXG4gICAgICAgIHBvc3NpYmxlTnVtYmVyc1tnZXRSYW5kb21JbnQoMCwgcG9zc2libGVOdW1iZXJzLmxlbmd0aCAtIDEpXVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBMSFNlcXVhdGlvbkxlbmd0aCA9IG9wZXJhdG9yc1RvVXNlLmxlbmd0aCArIExIU051bWJlckNvdW50O1xuICAgIGNvbnN0IExIU2VxdWF0aW9uID0gQXJyYXkoTEhTZXF1YXRpb25MZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBMSFNlcXVhdGlvbkxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob3BlcmF0b3JzVG9Vc2UubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICAgIGlmIChvcGVyYXRvcnNUb1VzZS5sZW5ndGggPT09IG1heE9wZXJhdG9yQ291bnQpIHtcbiAgICAgICAgTEhTZXF1YXRpb25baV0gPSBvcGVyYXRvcnNUb1VzZVswXTtcbiAgICAgICAgb3BlcmF0b3JzVG9Vc2Uuc3BsaWNlKDAsIDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpICE9PSAwICYmIGkgIT09IExIU2VxdWF0aW9uTGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAoIXBvc3NpYmxlT3BlcmF0b3JzLmluY2x1ZGVzKExIU2VxdWF0aW9uW2kgLSAxXSkpIHtcbiAgICAgICAgICBMSFNlcXVhdGlvbltpXSA9IG9wZXJhdG9yc1RvVXNlWzBdO1xuICAgICAgICAgIG9wZXJhdG9yc1RvVXNlLnNwbGljZSgwLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgTEhTZXF1YXRpb25MZW5ndGg7IGorKykge1xuICAgICAgaWYgKG51bWJlcnNUb1VzZS5sZW5ndGggPT09IDApIGJyZWFrO1xuICAgICAgaWYgKExIU2VxdWF0aW9uW2pdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgTEhTZXF1YXRpb25bal0gPSBudW1iZXJzVG9Vc2VbMF07XG4gICAgICAgIG51bWJlcnNUb1VzZS5zcGxpY2UoMCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZXFTdHJpbmcgPSBMSFNlcXVhdGlvbi5qb2luKFwiXCIpO1xuICAgIGNvbnN0IGZvcm1hdHRlZEVxQXJyYXkgPSBmb3JtYXRFcXVhdGlvbihlcVN0cmluZyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXR0ZWRFcUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZm9ybWF0dGVkRXFBcnJheVtpXS5sZW5ndGggPiAxICYmIGZvcm1hdHRlZEVxQXJyYXlbaV1bMF0gPT09IFwiMFwiKSB7XG4gICAgICAgIGxldCB0ZW1wX251bWJlciA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZm9ybWF0dGVkRXFBcnJheVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRlbXBfbnVtYmVyICs9IGdldFJhbmRvbUludCgxLCA5KS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdHRlZEVxQXJyYXkuc3BsaWNlKGksIDEsIHRlbXBfbnVtYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBSSFNBbnN3ZXIgPSBjYWxjdWxhdGVBcnJheShmb3JtYXRFcXVhdGlvbihlcVN0cmluZykpO1xuICAgIGlmICghUkhTQW5zd2VyKSByZXR1cm4gZ2VuZXJhdGVFcXVhdGlvbihsZW5ndGgpO1xuICAgIGNvbnN0IGZpbmFsRXF1YXRpb24gPSBlcVN0cmluZyArIFwiPVwiICsgUkhTQW5zd2VyO1xuICAgIGlmIChmaW5hbEVxdWF0aW9uLmxlbmd0aCAhPT0gZXF1YXRpb25MZW5ndGgpXG4gICAgICByZXR1cm4gZ2VuZXJhdGVFcXVhdGlvbihsZW5ndGgpO1xuXG4gICAgcmV0dXJuIGZpbmFsRXF1YXRpb247XG4gIH07XG5cbiAgY29uc3QgZm9ybWF0RXF1YXRpb24gPSAoZXhwcmVzc2lvbikgPT4ge1xuICAgIHZhciBjb3B5ID0gZXhwcmVzc2lvbjtcbiAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5yZXBsYWNlKC9bMC05XSsvZywgXCIjXCIpO1xuICAgIHZhciBudW1iZXJzID0gY29weS5zcGxpdCgvW14wLTlcXC5dKy8pLmZpbHRlcigobikgPT4gbik7XG4gICAgdmFyIG9wZXJhdG9ycyA9IGV4cHJlc3Npb24uc3BsaXQoXCIjXCIpLmZpbHRlcigobikgPT4gbik7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob3BlcmF0b3JzLmxlbmd0aCA9PT0gbnVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gob3BlcmF0b3JzW2ldKTtcbiAgICAgICAgcmVzdWx0LnB1c2gobnVtYmVyc1tpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChudW1iZXJzW2ldKTtcbiAgICAgICAgaWYgKGkgPCBvcGVyYXRvcnMubGVuZ3RoKSByZXN1bHQucHVzaChvcGVyYXRvcnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGNvbnN0IGNhbGN1bGF0ZUFycmF5ID0gKGFycmF5RXF1YXRpb24pID0+IHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCB0ZW1wX2FycmF5ID0gWy4uLmFycmF5RXF1YXRpb25dO1xuICAgIGNvbnN0IGRpdmlkZSA9IHRlbXBfYXJyYXkuaW5kZXhPZihcIi9cIik7XG4gICAgY29uc3QgbXVsdGlwbHkgPSB0ZW1wX2FycmF5LmluZGV4T2YoXCIqXCIpO1xuICAgIGNvbnN0IHN1YnN0cmFjdCA9IHRlbXBfYXJyYXkuaW5kZXhPZihcIi1cIik7XG4gICAgY29uc3QgYWRkID0gdGVtcF9hcnJheS5pbmRleE9mKFwiK1wiKTtcblxuICAgIGlmICh0ZW1wX2FycmF5Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnNlSW50KHRlbXBfYXJyYXlbMF0pO1xuXG4gICAgaWYgKGFkZCA9PT0gMCkge1xuICAgICAgdGVtcF9hcnJheS5zcGxpY2UoYWRkLCAxKTtcbiAgICB9XG4gICAgaWYgKHN1YnN0cmFjdCA9PT0gMCkge1xuICAgICAgaWYgKHRlbXBfYXJyYXlbc3Vic3RyYWN0ICsgMV0gPT09IFwiMFwiKSB7XG4gICAgICAgIHRlbXBfYXJyYXkuc3BsaWNlKHN1YnN0cmFjdCArIDEsIDEsIGdldFJhbmRvbUludCgxLCA5KS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHBhcnNlSW50KHRlbXBfYXJyYXlbc3Vic3RyYWN0XSArIHRlbXBfYXJyYXlbc3Vic3RyYWN0ICsgMV0pO1xuICAgICAgdGVtcF9hcnJheS5zcGxpY2Uoc3Vic3RyYWN0LCAyLCByZXN1bHQpO1xuICAgIH0gZWxzZSBpZiAoZGl2aWRlID4gMCkge1xuICAgICAgaWYgKHBhcnNlSW50KHRlbXBfYXJyYXlbZGl2aWRlICsgMV0pID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGlmIChcbiAgICAgICAgcGFyc2VJbnQodGVtcF9hcnJheVtkaXZpZGUgLSAxXSkgJSBwYXJzZUludCh0ZW1wX2FycmF5W2RpdmlkZSArIDFdKSAhPT1cbiAgICAgICAgMFxuICAgICAgKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICByZXN1bHQgPVxuICAgICAgICBwYXJzZUludCh0ZW1wX2FycmF5W2RpdmlkZSAtIDFdKSAvIHBhcnNlSW50KHRlbXBfYXJyYXlbZGl2aWRlICsgMV0pO1xuICAgICAgdGVtcF9hcnJheS5zcGxpY2UoZGl2aWRlIC0gMSwgMywgcmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKG11bHRpcGx5ID4gMCkge1xuICAgICAgcmVzdWx0ID1cbiAgICAgICAgcGFyc2VJbnQodGVtcF9hcnJheVttdWx0aXBseSAtIDFdKSAqIHBhcnNlSW50KHRlbXBfYXJyYXlbbXVsdGlwbHkgKyAxXSk7XG4gICAgICB0ZW1wX2FycmF5LnNwbGljZShtdWx0aXBseSAtIDEsIDMsIHJlc3VsdCk7XG4gICAgfSBlbHNlIGlmIChhZGQgPiAwKSB7XG4gICAgICByZXN1bHQgPSBwYXJzZUludCh0ZW1wX2FycmF5W2FkZCAtIDFdKSArIHBhcnNlSW50KHRlbXBfYXJyYXlbYWRkICsgMV0pO1xuICAgICAgdGVtcF9hcnJheS5zcGxpY2UoYWRkIC0gMSwgMywgcmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0cmFjdCA+IDApIHtcbiAgICAgIHJlc3VsdCA9XG4gICAgICAgIHBhcnNlSW50KHRlbXBfYXJyYXlbc3Vic3RyYWN0IC0gMV0pIC1cbiAgICAgICAgcGFyc2VJbnQodGVtcF9hcnJheVtzdWJzdHJhY3QgKyAxXSk7XG4gICAgICB0ZW1wX2FycmF5LnNwbGljZShzdWJzdHJhY3QgLSAxLCAzLCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsY3VsYXRlQXJyYXkodGVtcF9hcnJheSk7XG4gIH07XG5cbiAgY29uc3QgZ2V0UmFuZG9tSW50ID0gKG1pbiwgbWF4KSA9PiB7XG4gICAgbWluID0gTWF0aC5jZWlsKG1pbik7XG4gICAgbWF4ID0gTWF0aC5mbG9vcihtYXgpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKFxuICAgICAgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSArIG1pblxuICAgICk7IC8qIGZvciBtaW4gYW5kIG1heCBpbmNsdXNpdmUgKi9cbiAgfTtcblxuICBjb25zdCB2YWx1ZXMgPSB7XG4gICAgZ2VuZXJhdGVFcXVhdGlvbixcbiAgICBST1dTX0NPVU5ULFxuICAgIEVRVUFUSU9OX0xFTkdUSCxcbiAgICBjdXJyZW50SW5kZXgsXG4gICAgY3VycmVudEd1ZXNzLFxuICAgIGhhbmRsZUlucHV0LFxuICAgIGd1ZXNzZXMsXG4gICAgZXF1YXRpb24sXG4gICAgc2V0RXF1YXRpb24sXG4gICAgZXJyb3IsXG4gICAgc2V0RXJyb3IsXG4gICAgZ2FtZW92ZXIsXG4gICAgd2luLFxuICAgIGd1ZXNzZWRSZXN1bHQsXG4gICAgc2V0R3Vlc3NlZFJlc3VsdCxcbiAgICBnYW1lb3Zlck1vZGFsLFxuICAgIHNldEdhbWVvdmVyTW9kYWwsXG4gICAgcmVzZXRFdmVyeXRoaW5nLFxuICB9O1xuICByZXR1cm4gKFxuICAgIDxwbGF5ZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt2YWx1ZXN9PntjaGlsZHJlbn08L3BsYXllckNvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG5leHBvcnQgeyB1c2VQbGF5ZXIsIFBsYXllclByb3ZpZGVyIH07XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInBsYXllckNvbnRleHQiLCJ1c2VQbGF5ZXIiLCJQbGF5ZXJQcm92aWRlciIsImNoaWxkcmVuIiwiUk9XU19DT1VOVCIsIkVRVUFUSU9OX0xFTkdUSCIsImN1cnJlbnRHdWVzcyIsInNldEN1cnJlbnRHdWVzcyIsImN1cnJlbnRJbmRleCIsInNldEN1cnJlbnRJbmRleCIsIkFycmF5IiwiZmlsbCIsImd1ZXNzZXMiLCJzZXRHdWVzc2VzIiwiZ2FtZW92ZXIiLCJzZXRHYW1lb3ZlciIsIndpbiIsInNldFdpbiIsImVxdWF0aW9uIiwic2V0RXF1YXRpb24iLCJlcnJvciIsInNldEVycm9yIiwiZ2FtZW92ZXJNb2RhbCIsInNldEdhbWVvdmVyTW9kYWwiLCJndWVzc2VkUmVzdWx0Iiwic2V0R3Vlc3NlZFJlc3VsdCIsImhhbmRsZUlucHV0IiwiZSIsInZhbHVlIiwia2V5IiwiZXFGaWx0ZXIiLCJ0ZW1wX29wZXJhdG9ycyIsInRlc3QiLCJsZW5ndGgiLCJpbmNsdWRlcyIsInNwbGl0IiwiTEhTIiwiUkhTIiwiZm9ybWF0RXF1YXRpb24iLCJpIiwiY2FsY3VsYXRlQXJyYXkiLCJ0ZW1wX2d1ZXNzIiwicHJldiIsInNsaWNlIiwicmVzZXRFdmVyeXRoaW5nIiwiZ2VuZXJhdGVFcXVhdGlvbiIsImVxdWF0aW9uTGVuZ3RoIiwibWF4T3BlcmF0b3JDb3VudCIsIk1hdGgiLCJmbG9vciIsIm1pbk9wZXJhdG9yQ291bnQiLCJwb3NzaWJsZU9wZXJhdG9ycyIsInBvc3NpYmxlTnVtYmVycyIsIm9wZXJhdG9yc1RvVXNlIiwibnVtYmVyc1RvVXNlIiwicmFuZG9tT3BlcmF0b3JDb3VudCIsImdldFJhbmRvbUludCIsInB1c2giLCJzcGxpY2UiLCJMSFNOdW1iZXJDb3VudCIsIkxIU2VxdWF0aW9uTGVuZ3RoIiwiTEhTZXF1YXRpb24iLCJqIiwidW5kZWZpbmVkIiwiZXFTdHJpbmciLCJqb2luIiwiZm9ybWF0dGVkRXFBcnJheSIsInRlbXBfbnVtYmVyIiwidG9TdHJpbmciLCJSSFNBbnN3ZXIiLCJmaW5hbEVxdWF0aW9uIiwiZXhwcmVzc2lvbiIsImNvcHkiLCJyZXBsYWNlIiwibnVtYmVycyIsImZpbHRlciIsIm4iLCJvcGVyYXRvcnMiLCJyZXN1bHQiLCJhcnJheUVxdWF0aW9uIiwidGVtcF9hcnJheSIsImRpdmlkZSIsImluZGV4T2YiLCJtdWx0aXBseSIsInN1YnN0cmFjdCIsImFkZCIsInBhcnNlSW50IiwibWluIiwibWF4IiwiY2VpbCIsInJhbmRvbSIsInZhbHVlcyIsIlByb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./contexts/PlayerContext.jsx\n");

/***/ })

});