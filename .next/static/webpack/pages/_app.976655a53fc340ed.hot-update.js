"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./contexts/PlayerContext.jsx":
/*!************************************!*\
  !*** ./contexts/PlayerContext.jsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PlayerProvider\": function() { return /* binding */ PlayerProvider; },\n/* harmony export */   \"usePlayer\": function() { return /* binding */ usePlayer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s2, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s2 = _i.next()).done); _n = true){\n            _arr.push(_s2.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar _this = undefined;\n\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\nvar playerContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)();\nvar usePlayer = function() {\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(playerContext);\n};\n_s(usePlayer, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar PlayerProvider = function(param) {\n    var children = param.children;\n    _s1();\n    var ROWS_COUNT = 6;\n    var EQUATION_LENGTH = 3;\n    var ref9 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), currentGuess = ref9[0], setCurrentGuess = ref9[1];\n    var ref1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0), currentIndex = ref1[0], setCurrentIndex = ref1[1];\n    var ref2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Array(ROWS_COUNT).fill(null)), guesses = ref2[0], setGuesses = ref2[1];\n    var ref3 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), gameover = ref3[0], setGameover = ref3[1];\n    var ref4 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), win = ref4[0], setWin = ref4[1];\n    var ref5 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), equation = ref5[0], setEquation = ref5[1];\n    var ref6 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), error = ref6[0], setError = ref6[1];\n    var ref7 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), gameoverModal = ref7[0], setGameoverModal = ref7[1];\n    var ref8 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Array(ROWS_COUNT).fill(null)), guessedResult = ref8[0], setGuessedResult = ref8[1];\n    var handleInput = function(e) {\n        var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n        var key = e.key || value;\n        if (gameover) return;\n        var eqFilter = /^[0-9+\\-*/=]|(Backspace|Enter)+$/;\n        var temp_operators = [\n            \"+\",\n            \"-\",\n            \"*\",\n            \"/\"\n        ];\n        if (!eqFilter.test(key)) {\n            return;\n        }\n        if (key === \"Enter\") {\n            if (currentGuess.length !== EQUATION_LENGTH) {\n                setError(\"You need to fill up the squares.\");\n                return;\n            }\n            /*if (\n        !currentGuess.includes(\"+\") &&\n        !currentGuess.includes(\"-\") &&\n        !currentGuess.includes(\"*\") &&\n        !currentGuess.includes(\"/\")\n      ) {\n        setError(\"The equation needs to include at least one operator.\");\n        return;\n      }\n      if (!currentGuess.includes(\"=\")) {\n        setError(\"The equation needs to include '='.\");\n        return;\n      }\n\n      if (currentGuess[0] === \"/\" || currentGuess[0] === \"*\") {\n        setError(\"Invalid Equation.\");\n        return;\n      }\n\n      if (currentGuess.split(\"=\").length - 1 !== 1) {\n        setError(\"There are multiple '=' in the equation.\");\n        return;\n      }*/ var ref = _slicedToArray(currentGuess.split(\"=\"), 2), LHS = ref[0], RHS = ref[1];\n            LHS = formatEquation(LHS);\n            RHS = formatEquation(RHS);\n            for(var i = 0; i < LHS.length; i++){\n                if (LHS[i].length > 1) {\n                    if (i === LHS.length - 1) {\n                        if (temp_operators.includes(LHS[i][0])) {\n                            setError(\"Invalid Equation.\");\n                            return;\n                        }\n                    }\n                    if (temp_operators.includes(LHS[i][0]) && temp_operators.includes(LHS[i][1])) {\n                        setError(\"Invalid Equation.\");\n                        return;\n                    }\n                }\n            }\n            for(var i1 = 0; i1 < RHS.length; i1++){\n                if (RHS[i1].length > 1) {\n                    if (i1 === RHS.length - 1) {\n                        if (temp_operators.includes(RHS[i1][0])) {\n                            setError(\"Invalid Equation.\");\n                            return;\n                        }\n                    }\n                    if (temp_operators.includes(RHS[i1][0]) && temp_operators.includes(RHS[i1][1])) {\n                        setError(\"Invalid Equation.\");\n                        return;\n                    }\n                }\n            }\n            if (calculateArray(LHS) !== calculateArray(RHS)) {\n                setError(\"Left side in not equal to the right side.\");\n                return;\n            }\n            var temp_guess = _toConsumableArray(guesses);\n            temp_guess[currentIndex] = currentGuess;\n            setGuesses(temp_guess);\n            if (currentGuess === equation) {\n                setGameover(true);\n                setWin(true);\n            } else if (currentIndex === ROWS_COUNT - 1) {\n                setGameover(true);\n            }\n            setCurrentIndex(function(prev) {\n                return prev + 1;\n            });\n            setCurrentGuess(\"\");\n            return;\n        }\n        if (key === \"Backspace\") {\n            setCurrentGuess(function(prev) {\n                return prev.slice(0, -1);\n            });\n            return;\n        }\n        if (currentGuess.length !== EQUATION_LENGTH) {\n            setCurrentGuess(function(prev) {\n                return prev + key;\n            });\n        }\n    };\n    var resetEverything = function() {\n        setCurrentGuess(\"\");\n        setCurrentIndex(0);\n        setGuesses(Array(ROWS_COUNT).fill(null));\n        setGameover(false);\n        setWin(false);\n        setEquation(\"\");\n        setError(\"\");\n        setGameoverModal(false);\n        setGuessedResult(Array(ROWS_COUNT).fill(null));\n    };\n    var generateEquation = function(length) {\n        var equationLength = length;\n        var maxOperatorCount = Math.floor(equationLength / 2 - 1);\n        var minOperatorCount = 1;\n        var possibleOperators = [\n            \"+\",\n            \"-\",\n            \"/\",\n            \"*\"\n        ];\n        var possibleNumbers = \"0123456789\";\n        var operatorsToUse = [];\n        var numbersToUse = [];\n        var randomOperatorCount = getRandomInt(minOperatorCount, maxOperatorCount);\n        for(var i = 0; i < randomOperatorCount; i++){\n            operatorsToUse.push(possibleOperators[getRandomInt(0, possibleOperators.length - 1)]);\n        }\n        if (operatorsToUse[0] !== \"-\" && operatorsToUse.length === maxOperatorCount) {\n            operatorsToUse.splice(-1, 1);\n        }\n        var LHSNumberCount = maxOperatorCount > 1 && operatorsToUse.length === maxOperatorCount ? operatorsToUse.length : getRandomInt(operatorsToUse.length + 1, equationLength - operatorsToUse.length - 2);\n        for(var i2 = 0; i2 < LHSNumberCount; i2++){\n            numbersToUse.push(possibleNumbers[getRandomInt(0, possibleNumbers.length - 1)]);\n        }\n        var LHSequationLength = operatorsToUse.length + LHSNumberCount;\n        var LHSequation = Array(LHSequationLength);\n        for(var i3 = 0; i3 < LHSequationLength; i3++){\n            if (operatorsToUse.length === 0) break;\n            if (operatorsToUse.length === maxOperatorCount) {\n                LHSequation[i3] = operatorsToUse[0];\n                operatorsToUse.splice(0, 1);\n                continue;\n            }\n            if (i3 !== 0 && i3 !== LHSequationLength - 1) {\n                if (!possibleOperators.includes(LHSequation[i3 - 1])) {\n                    LHSequation[i3] = operatorsToUse[0];\n                    operatorsToUse.splice(0, 1);\n                }\n            }\n        }\n        for(var j = 0; j < LHSequationLength; j++){\n            if (numbersToUse.length === 0) break;\n            if (LHSequation[j] === undefined) {\n                LHSequation[j] = numbersToUse[0];\n                numbersToUse.splice(0, 1);\n            }\n        }\n        var eqString = LHSequation.join(\"\");\n        var formattedEqArray = formatEquation(eqString);\n        for(var i4 = 0; i4 < formattedEqArray.length; i4++){\n            if (formattedEqArray[i4].length > 1 && formattedEqArray[i4][0] === \"0\") {\n                var temp_number = \"\";\n                for(var j1 = 0; j1 < formattedEqArray[i4].length; j1++){\n                    temp_number += getRandomInt(1, 9).toString();\n                }\n                formattedEqArray.splice(i4, 1, temp_number);\n            }\n        }\n        var RHSAnswer = calculateArray(formatEquation(eqString));\n        if (!RHSAnswer) return generateEquation(length);\n        var finalEquation = eqString + \"=\" + RHSAnswer;\n        if (finalEquation.length !== equationLength) return generateEquation(length);\n        return finalEquation;\n    };\n    var formatEquation = function(expression) {\n        var copy = expression;\n        expression = expression.replace(/[0-9]+/g, \"#\");\n        var numbers = copy.split(/[^0-9\\.]+/).filter(function(n) {\n            return n;\n        });\n        var operators = expression.split(\"#\").filter(function(n) {\n            return n;\n        });\n        var result = [];\n        for(var i = 0; i < numbers.length; i++){\n            if (operators.length === numbers.length) {\n                result.push(operators[i]);\n                result.push(numbers[i]);\n            } else {\n                result.push(numbers[i]);\n                if (i < operators.length) result.push(operators[i]);\n            }\n        }\n        return result;\n    };\n    var calculateArray = function(arrayEquation) {\n        var result;\n        //let temp_array = [...arrayEquation];\n        var divide = temp_array.indexOf(\"/\");\n        var multiply = temp_array.indexOf(\"*\");\n        var substract = temp_array.indexOf(\"-\");\n        var add = temp_array.indexOf(\"+\");\n        if (temp_array.length === 1) return parseInt(temp_array[0]);\n        if (add === 0) {\n            temp_array.splice(add, 1);\n        }\n        if (substract === 0) {\n            if (temp_array[substract + 1] === \"0\") {\n                temp_array.splice(substract + 1, 1, getRandomInt(1, 9).toString());\n            }\n            result = parseInt(temp_array[substract] + temp_array[substract + 1]);\n            temp_array.splice(substract, 2, result);\n        } else if (divide > 0) {\n            if (parseInt(temp_array[divide + 1]) === 0) return false;\n            if (parseInt(temp_array[divide - 1]) % parseInt(temp_array[divide + 1]) !== 0) return false;\n            result = parseInt(temp_array[divide - 1]) / parseInt(temp_array[divide + 1]);\n            temp_array.splice(divide - 1, 3, result);\n        } else if (multiply > 0) {\n            result = parseInt(temp_array[multiply - 1]) * parseInt(temp_array[multiply + 1]);\n            temp_array.splice(multiply - 1, 3, result);\n        } else if (add > 0) {\n            result = parseInt(temp_array[add - 1]) + parseInt(temp_array[add + 1]);\n            temp_array.splice(add - 1, 3, result);\n        } else if (substract > 0) {\n            result = parseInt(temp_array[substract - 1]) - parseInt(temp_array[substract + 1]);\n            temp_array.splice(substract - 1, 3, result);\n        }\n        return calculateArray(temp_array);\n    };\n    var getRandomInt = function(min, max) {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min + 1) + min); /* for min and max inclusive */ \n    };\n    var values = {\n        generateEquation: generateEquation,\n        ROWS_COUNT: ROWS_COUNT,\n        EQUATION_LENGTH: EQUATION_LENGTH,\n        currentIndex: currentIndex,\n        currentGuess: currentGuess,\n        handleInput: handleInput,\n        guesses: guesses,\n        equation: equation,\n        setEquation: setEquation,\n        error: error,\n        setError: setError,\n        gameover: gameover,\n        win: win,\n        guessedResult: guessedResult,\n        setGuessedResult: setGuessedResult,\n        gameoverModal: gameoverModal,\n        setGameoverModal: setGameoverModal,\n        resetEverything: resetEverything\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(playerContext.Provider, {\n        value: values,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/lucasklenovich/Documents/GitHub/ngt1/contexts/PlayerContext.jsx\",\n        lineNumber: 323,\n        columnNumber: 5\n    }, _this);\n};\n_s1(PlayerProvider, \"5v9xnvGDx2ysOMyYGYJq6NoNOVk=\");\n_c = PlayerProvider;\n\nvar _c;\n$RefreshReg$(_c, \"PlayerProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFXO1FBQ1hkLE9BQU8sRUFBUEEsT0FBTztRQUNQTSxRQUFRLEVBQVJBLFFBQVE7UUFDUkMsV0FBVyxFQUFYQSxXQUFXO1FBQ1hDLEtBQUssRUFBTEEsS0FBSztRQUNMQyxRQUFRLEVBQVJBLFFBQVE7UUFDUlAsUUFBUSxFQUFSQSxRQUFRO1FBQ1JFLEdBQUcsRUFBSEEsR0FBRztRQUNIUSxhQUFhLEVBQWJBLGFBQWE7UUFDYkMsZ0JBQWdCLEVBQWhCQSxnQkFBZ0I7UUFDaEJILGFBQWEsRUFBYkEsYUFBYTtRQUNiQyxnQkFBZ0IsRUFBaEJBLGdCQUFnQjtRQUNoQnFCLGVBQWUsRUFBZkEsZUFBZTtLQUNoQjtJQUNELHFCQUNFLDhEQUFDNUMsYUFBYSxDQUFDNEYsUUFBUTtRQUFDaEUsS0FBSyxFQUFFK0QsTUFBTTtrQkFBR3hGLFFBQVE7Ozs7O2FBQTBCLENBQzFFO0NBQ0g7SUE1VEtELGNBQWM7QUFBZEEsS0FBQUEsY0FBYztBQThUaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29udGV4dHMvUGxheWVyQ29udGV4dC5qc3g/MTViMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG5jb25zdCBwbGF5ZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgpO1xuXG5jb25zdCB1c2VQbGF5ZXIgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KHBsYXllckNvbnRleHQpO1xufTtcblxuY29uc3QgUGxheWVyUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFJPV1NfQ09VTlQgPSA2O1xuICBjb25zdCBFUVVBVElPTl9MRU5HVEggPSAzO1xuICBjb25zdCBbY3VycmVudEd1ZXNzLCBzZXRDdXJyZW50R3Vlc3NdID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtjdXJyZW50SW5kZXgsIHNldEN1cnJlbnRJbmRleF0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW2d1ZXNzZXMsIHNldEd1ZXNzZXNdID0gdXNlU3RhdGUoQXJyYXkoUk9XU19DT1VOVCkuZmlsbChudWxsKSk7XG4gIGNvbnN0IFtnYW1lb3Zlciwgc2V0R2FtZW92ZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbd2luLCBzZXRXaW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXF1YXRpb24sIHNldEVxdWF0aW9uXSA9IHVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBbZ2FtZW92ZXJNb2RhbCwgc2V0R2FtZW92ZXJNb2RhbF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtndWVzc2VkUmVzdWx0LCBzZXRHdWVzc2VkUmVzdWx0XSA9IHVzZVN0YXRlKFxuICAgIEFycmF5KFJPV1NfQ09VTlQpLmZpbGwobnVsbClcbiAgKTtcblxuICBjb25zdCBoYW5kbGVJbnB1dCA9IChlLCB2YWx1ZSA9IFwiXCIpID0+IHtcbiAgICBjb25zdCBrZXkgPSBlLmtleSB8fCB2YWx1ZTtcbiAgICBpZiAoZ2FtZW92ZXIpIHJldHVybjtcbiAgICBjb25zdCBlcUZpbHRlciA9IC9eWzAtOStcXC0qLz1dfChCYWNrc3BhY2V8RW50ZXIpKyQvO1xuICAgIGNvbnN0IHRlbXBfb3BlcmF0b3JzID0gW1wiK1wiLCBcIi1cIiwgXCIqXCIsIFwiL1wiXTtcbiAgICBpZiAoIWVxRmlsdGVyLnRlc3Qoa2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgIGlmIChjdXJyZW50R3Vlc3MubGVuZ3RoICE9PSBFUVVBVElPTl9MRU5HVEgpIHtcbiAgICAgICAgc2V0RXJyb3IoXCJZb3UgbmVlZCB0byBmaWxsIHVwIHRoZSBzcXVhcmVzLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvKmlmIChcbiAgICAgICAgIWN1cnJlbnRHdWVzcy5pbmNsdWRlcyhcIitcIikgJiZcbiAgICAgICAgIWN1cnJlbnRHdWVzcy5pbmNsdWRlcyhcIi1cIikgJiZcbiAgICAgICAgIWN1cnJlbnRHdWVzcy5pbmNsdWRlcyhcIipcIikgJiZcbiAgICAgICAgIWN1cnJlbnRHdWVzcy5pbmNsdWRlcyhcIi9cIilcbiAgICAgICkge1xuICAgICAgICBzZXRFcnJvcihcIlRoZSBlcXVhdGlvbiBuZWVkcyB0byBpbmNsdWRlIGF0IGxlYXN0IG9uZSBvcGVyYXRvci5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghY3VycmVudEd1ZXNzLmluY2x1ZGVzKFwiPVwiKSkge1xuICAgICAgICBzZXRFcnJvcihcIlRoZSBlcXVhdGlvbiBuZWVkcyB0byBpbmNsdWRlICc9Jy5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnRHdWVzc1swXSA9PT0gXCIvXCIgfHwgY3VycmVudEd1ZXNzWzBdID09PSBcIipcIikge1xuICAgICAgICBzZXRFcnJvcihcIkludmFsaWQgRXF1YXRpb24uXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50R3Vlc3Muc3BsaXQoXCI9XCIpLmxlbmd0aCAtIDEgIT09IDEpIHtcbiAgICAgICAgc2V0RXJyb3IoXCJUaGVyZSBhcmUgbXVsdGlwbGUgJz0nIGluIHRoZSBlcXVhdGlvbi5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0qL1xuICAgICAgbGV0IFtMSFMsIFJIU10gPSBjdXJyZW50R3Vlc3Muc3BsaXQoXCI9XCIpO1xuXG4gICAgICBMSFMgPSBmb3JtYXRFcXVhdGlvbihMSFMpO1xuICAgICAgUkhTID0gZm9ybWF0RXF1YXRpb24oUkhTKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBMSFMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKExIU1tpXS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgaWYgKGkgPT09IExIUy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBpZiAodGVtcF9vcGVyYXRvcnMuaW5jbHVkZXMoTEhTW2ldWzBdKSkge1xuICAgICAgICAgICAgICBzZXRFcnJvcihcIkludmFsaWQgRXF1YXRpb24uXCIpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRlbXBfb3BlcmF0b3JzLmluY2x1ZGVzKExIU1tpXVswXSkgJiZcbiAgICAgICAgICAgIHRlbXBfb3BlcmF0b3JzLmluY2x1ZGVzKExIU1tpXVsxXSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHNldEVycm9yKFwiSW52YWxpZCBFcXVhdGlvbi5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUkhTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChSSFNbaV0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGlmIChpID09PSBSSFMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgaWYgKHRlbXBfb3BlcmF0b3JzLmluY2x1ZGVzKFJIU1tpXVswXSkpIHtcbiAgICAgICAgICAgICAgc2V0RXJyb3IoXCJJbnZhbGlkIEVxdWF0aW9uLlwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0ZW1wX29wZXJhdG9ycy5pbmNsdWRlcyhSSFNbaV1bMF0pICYmXG4gICAgICAgICAgICB0ZW1wX29wZXJhdG9ycy5pbmNsdWRlcyhSSFNbaV1bMV0pXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBzZXRFcnJvcihcIkludmFsaWQgRXF1YXRpb24uXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FsY3VsYXRlQXJyYXkoTEhTKSAhPT0gY2FsY3VsYXRlQXJyYXkoUkhTKSkge1xuICAgICAgICBzZXRFcnJvcihcIkxlZnQgc2lkZSBpbiBub3QgZXF1YWwgdG8gdGhlIHJpZ2h0IHNpZGUuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRlbXBfZ3Vlc3MgPSBbLi4uZ3Vlc3Nlc107XG4gICAgICB0ZW1wX2d1ZXNzW2N1cnJlbnRJbmRleF0gPSBjdXJyZW50R3Vlc3M7XG4gICAgICBzZXRHdWVzc2VzKHRlbXBfZ3Vlc3MpO1xuICAgICAgaWYgKGN1cnJlbnRHdWVzcyA9PT0gZXF1YXRpb24pIHtcbiAgICAgICAgc2V0R2FtZW92ZXIodHJ1ZSk7XG4gICAgICAgIHNldFdpbih0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudEluZGV4ID09PSBST1dTX0NPVU5UIC0gMSkge1xuICAgICAgICBzZXRHYW1lb3Zlcih0cnVlKTtcbiAgICAgIH1cbiAgICAgIHNldEN1cnJlbnRJbmRleCgocHJldikgPT4gcHJldiArIDEpO1xuICAgICAgc2V0Q3VycmVudEd1ZXNzKFwiXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSBcIkJhY2tzcGFjZVwiKSB7XG4gICAgICBzZXRDdXJyZW50R3Vlc3MoKHByZXYpID0+IHByZXYuc2xpY2UoMCwgLTEpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRHdWVzcy5sZW5ndGggIT09IEVRVUFUSU9OX0xFTkdUSCkge1xuICAgICAgc2V0Q3VycmVudEd1ZXNzKChwcmV2KSA9PiBwcmV2ICsga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVzZXRFdmVyeXRoaW5nID0gKCkgPT4ge1xuICAgIHNldEN1cnJlbnRHdWVzcyhcIlwiKTtcbiAgICBzZXRDdXJyZW50SW5kZXgoMCk7XG4gICAgc2V0R3Vlc3NlcyhBcnJheShST1dTX0NPVU5UKS5maWxsKG51bGwpKTtcbiAgICBzZXRHYW1lb3ZlcihmYWxzZSk7XG4gICAgc2V0V2luKGZhbHNlKTtcbiAgICBzZXRFcXVhdGlvbihcIlwiKTtcbiAgICBzZXRFcnJvcihcIlwiKTtcbiAgICBzZXRHYW1lb3Zlck1vZGFsKGZhbHNlKTtcbiAgICBzZXRHdWVzc2VkUmVzdWx0KEFycmF5KFJPV1NfQ09VTlQpLmZpbGwobnVsbCkpO1xuICB9O1xuXG4gIGNvbnN0IGdlbmVyYXRlRXF1YXRpb24gPSAobGVuZ3RoKSA9PiB7XG4gICAgY29uc3QgZXF1YXRpb25MZW5ndGggPSBsZW5ndGg7XG4gICAgY29uc3QgbWF4T3BlcmF0b3JDb3VudCA9IE1hdGguZmxvb3IoZXF1YXRpb25MZW5ndGggLyAyIC0gMSk7XG4gICAgY29uc3QgbWluT3BlcmF0b3JDb3VudCA9IDE7XG4gICAgY29uc3QgcG9zc2libGVPcGVyYXRvcnMgPSBbXCIrXCIsIFwiLVwiLCBcIi9cIiwgXCIqXCJdO1xuICAgIGNvbnN0IHBvc3NpYmxlTnVtYmVycyA9IFwiMDEyMzQ1Njc4OVwiO1xuICAgIGNvbnN0IG9wZXJhdG9yc1RvVXNlID0gW107XG4gICAgY29uc3QgbnVtYmVyc1RvVXNlID0gW107XG5cbiAgICBjb25zdCByYW5kb21PcGVyYXRvckNvdW50ID0gZ2V0UmFuZG9tSW50KFxuICAgICAgbWluT3BlcmF0b3JDb3VudCxcbiAgICAgIG1heE9wZXJhdG9yQ291bnRcbiAgICApO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5kb21PcGVyYXRvckNvdW50OyBpKyspIHtcbiAgICAgIG9wZXJhdG9yc1RvVXNlLnB1c2goXG4gICAgICAgIHBvc3NpYmxlT3BlcmF0b3JzW2dldFJhbmRvbUludCgwLCBwb3NzaWJsZU9wZXJhdG9ycy5sZW5ndGggLSAxKV1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb3BlcmF0b3JzVG9Vc2VbMF0gIT09IFwiLVwiICYmXG4gICAgICBvcGVyYXRvcnNUb1VzZS5sZW5ndGggPT09IG1heE9wZXJhdG9yQ291bnRcbiAgICApIHtcbiAgICAgIG9wZXJhdG9yc1RvVXNlLnNwbGljZSgtMSwgMSk7XG4gICAgfVxuXG4gICAgY29uc3QgTEhTTnVtYmVyQ291bnQgPVxuICAgICAgbWF4T3BlcmF0b3JDb3VudCA+IDEgJiYgb3BlcmF0b3JzVG9Vc2UubGVuZ3RoID09PSBtYXhPcGVyYXRvckNvdW50XG4gICAgICAgID8gb3BlcmF0b3JzVG9Vc2UubGVuZ3RoXG4gICAgICAgIDogZ2V0UmFuZG9tSW50KFxuICAgICAgICAgICAgb3BlcmF0b3JzVG9Vc2UubGVuZ3RoICsgMSxcbiAgICAgICAgICAgIGVxdWF0aW9uTGVuZ3RoIC0gb3BlcmF0b3JzVG9Vc2UubGVuZ3RoIC0gMlxuICAgICAgICAgICk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IExIU051bWJlckNvdW50OyBpKyspIHtcbiAgICAgIG51bWJlcnNUb1VzZS5wdXNoKFxuICAgICAgICBwb3NzaWJsZU51bWJlcnNbZ2V0UmFuZG9tSW50KDAsIHBvc3NpYmxlTnVtYmVycy5sZW5ndGggLSAxKV1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgTEhTZXF1YXRpb25MZW5ndGggPSBvcGVyYXRvcnNUb1VzZS5sZW5ndGggKyBMSFNOdW1iZXJDb3VudDtcbiAgICBjb25zdCBMSFNlcXVhdGlvbiA9IEFycmF5KExIU2VxdWF0aW9uTGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTEhTZXF1YXRpb25MZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9wZXJhdG9yc1RvVXNlLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgICBpZiAob3BlcmF0b3JzVG9Vc2UubGVuZ3RoID09PSBtYXhPcGVyYXRvckNvdW50KSB7XG4gICAgICAgIExIU2VxdWF0aW9uW2ldID0gb3BlcmF0b3JzVG9Vc2VbMF07XG4gICAgICAgIG9wZXJhdG9yc1RvVXNlLnNwbGljZSgwLCAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaSAhPT0gMCAmJiBpICE9PSBMSFNlcXVhdGlvbkxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKCFwb3NzaWJsZU9wZXJhdG9ycy5pbmNsdWRlcyhMSFNlcXVhdGlvbltpIC0gMV0pKSB7XG4gICAgICAgICAgTEhTZXF1YXRpb25baV0gPSBvcGVyYXRvcnNUb1VzZVswXTtcbiAgICAgICAgICBvcGVyYXRvcnNUb1VzZS5zcGxpY2UoMCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IExIU2VxdWF0aW9uTGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChudW1iZXJzVG9Vc2UubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICAgIGlmIChMSFNlcXVhdGlvbltqXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIExIU2VxdWF0aW9uW2pdID0gbnVtYmVyc1RvVXNlWzBdO1xuICAgICAgICBudW1iZXJzVG9Vc2Uuc3BsaWNlKDAsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGVxU3RyaW5nID0gTEhTZXF1YXRpb24uam9pbihcIlwiKTtcbiAgICBjb25zdCBmb3JtYXR0ZWRFcUFycmF5ID0gZm9ybWF0RXF1YXRpb24oZXFTdHJpbmcpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0dGVkRXFBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGZvcm1hdHRlZEVxQXJyYXlbaV0ubGVuZ3RoID4gMSAmJiBmb3JtYXR0ZWRFcUFycmF5W2ldWzBdID09PSBcIjBcIikge1xuICAgICAgICBsZXQgdGVtcF9udW1iZXIgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZvcm1hdHRlZEVxQXJyYXlbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0ZW1wX251bWJlciArPSBnZXRSYW5kb21JbnQoMSwgOSkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3JtYXR0ZWRFcUFycmF5LnNwbGljZShpLCAxLCB0ZW1wX251bWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgUkhTQW5zd2VyID0gY2FsY3VsYXRlQXJyYXkoZm9ybWF0RXF1YXRpb24oZXFTdHJpbmcpKTtcbiAgICBpZiAoIVJIU0Fuc3dlcikgcmV0dXJuIGdlbmVyYXRlRXF1YXRpb24obGVuZ3RoKTtcbiAgICBjb25zdCBmaW5hbEVxdWF0aW9uID0gZXFTdHJpbmcgKyBcIj1cIiArIFJIU0Fuc3dlcjtcbiAgICBpZiAoZmluYWxFcXVhdGlvbi5sZW5ndGggIT09IGVxdWF0aW9uTGVuZ3RoKVxuICAgICAgcmV0dXJuIGdlbmVyYXRlRXF1YXRpb24obGVuZ3RoKTtcblxuICAgIHJldHVybiBmaW5hbEVxdWF0aW9uO1xuICB9O1xuXG4gIGNvbnN0IGZvcm1hdEVxdWF0aW9uID0gKGV4cHJlc3Npb24pID0+IHtcbiAgICB2YXIgY29weSA9IGV4cHJlc3Npb247XG4gICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ucmVwbGFjZSgvWzAtOV0rL2csIFwiI1wiKTtcbiAgICB2YXIgbnVtYmVycyA9IGNvcHkuc3BsaXQoL1teMC05XFwuXSsvKS5maWx0ZXIoKG4pID0+IG4pO1xuICAgIHZhciBvcGVyYXRvcnMgPSBleHByZXNzaW9uLnNwbGl0KFwiI1wiKS5maWx0ZXIoKG4pID0+IG4pO1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9wZXJhdG9ycy5sZW5ndGggPT09IG51bWJlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG9wZXJhdG9yc1tpXSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKG51bWJlcnNbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobnVtYmVyc1tpXSk7XG4gICAgICAgIGlmIChpIDwgb3BlcmF0b3JzLmxlbmd0aCkgcmVzdWx0LnB1c2gob3BlcmF0b3JzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBjb25zdCBjYWxjdWxhdGVBcnJheSA9IChhcnJheUVxdWF0aW9uKSA9PiB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICAvL2xldCB0ZW1wX2FycmF5ID0gWy4uLmFycmF5RXF1YXRpb25dO1xuICAgIGNvbnN0IGRpdmlkZSA9IHRlbXBfYXJyYXkuaW5kZXhPZihcIi9cIik7XG4gICAgY29uc3QgbXVsdGlwbHkgPSB0ZW1wX2FycmF5LmluZGV4T2YoXCIqXCIpO1xuICAgIGNvbnN0IHN1YnN0cmFjdCA9IHRlbXBfYXJyYXkuaW5kZXhPZihcIi1cIik7XG4gICAgY29uc3QgYWRkID0gdGVtcF9hcnJheS5pbmRleE9mKFwiK1wiKTtcblxuICAgIGlmICh0ZW1wX2FycmF5Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnNlSW50KHRlbXBfYXJyYXlbMF0pO1xuXG4gICAgaWYgKGFkZCA9PT0gMCkge1xuICAgICAgdGVtcF9hcnJheS5zcGxpY2UoYWRkLCAxKTtcbiAgICB9XG4gICAgaWYgKHN1YnN0cmFjdCA9PT0gMCkge1xuICAgICAgaWYgKHRlbXBfYXJyYXlbc3Vic3RyYWN0ICsgMV0gPT09IFwiMFwiKSB7XG4gICAgICAgIHRlbXBfYXJyYXkuc3BsaWNlKHN1YnN0cmFjdCArIDEsIDEsIGdldFJhbmRvbUludCgxLCA5KS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHBhcnNlSW50KHRlbXBfYXJyYXlbc3Vic3RyYWN0XSArIHRlbXBfYXJyYXlbc3Vic3RyYWN0ICsgMV0pO1xuICAgICAgdGVtcF9hcnJheS5zcGxpY2Uoc3Vic3RyYWN0LCAyLCByZXN1bHQpO1xuICAgIH0gZWxzZSBpZiAoZGl2aWRlID4gMCkge1xuICAgICAgaWYgKHBhcnNlSW50KHRlbXBfYXJyYXlbZGl2aWRlICsgMV0pID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGlmIChcbiAgICAgICAgcGFyc2VJbnQodGVtcF9hcnJheVtkaXZpZGUgLSAxXSkgJSBwYXJzZUludCh0ZW1wX2FycmF5W2RpdmlkZSArIDFdKSAhPT1cbiAgICAgICAgMFxuICAgICAgKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICByZXN1bHQgPVxuICAgICAgICBwYXJzZUludCh0ZW1wX2FycmF5W2RpdmlkZSAtIDFdKSAvIHBhcnNlSW50KHRlbXBfYXJyYXlbZGl2aWRlICsgMV0pO1xuICAgICAgdGVtcF9hcnJheS5zcGxpY2UoZGl2aWRlIC0gMSwgMywgcmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKG11bHRpcGx5ID4gMCkge1xuICAgICAgcmVzdWx0ID1cbiAgICAgICAgcGFyc2VJbnQodGVtcF9hcnJheVttdWx0aXBseSAtIDFdKSAqIHBhcnNlSW50KHRlbXBfYXJyYXlbbXVsdGlwbHkgKyAxXSk7XG4gICAgICB0ZW1wX2FycmF5LnNwbGljZShtdWx0aXBseSAtIDEsIDMsIHJlc3VsdCk7XG4gICAgfSBlbHNlIGlmIChhZGQgPiAwKSB7XG4gICAgICByZXN1bHQgPSBwYXJzZUludCh0ZW1wX2FycmF5W2FkZCAtIDFdKSArIHBhcnNlSW50KHRlbXBfYXJyYXlbYWRkICsgMV0pO1xuICAgICAgdGVtcF9hcnJheS5zcGxpY2UoYWRkIC0gMSwgMywgcmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0cmFjdCA+IDApIHtcbiAgICAgIHJlc3VsdCA9XG4gICAgICAgIHBhcnNlSW50KHRlbXBfYXJyYXlbc3Vic3RyYWN0IC0gMV0pIC1cbiAgICAgICAgcGFyc2VJbnQodGVtcF9hcnJheVtzdWJzdHJhY3QgKyAxXSk7XG4gICAgICB0ZW1wX2FycmF5LnNwbGljZShzdWJzdHJhY3QgLSAxLCAzLCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsY3VsYXRlQXJyYXkodGVtcF9hcnJheSk7XG4gIH07XG5cbiAgY29uc3QgZ2V0UmFuZG9tSW50ID0gKG1pbiwgbWF4KSA9PiB7XG4gICAgbWluID0gTWF0aC5jZWlsKG1pbik7XG4gICAgbWF4ID0gTWF0aC5mbG9vcihtYXgpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKFxuICAgICAgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSArIG1pblxuICAgICk7IC8qIGZvciBtaW4gYW5kIG1heCBpbmNsdXNpdmUgKi9cbiAgfTtcblxuICBjb25zdCB2YWx1ZXMgPSB7XG4gICAgZ2VuZXJhdGVFcXVhdGlvbixcbiAgICBST1dTX0NPVU5ULFxuICAgIEVRVUFUSU9OX0xFTkdUSCxcbiAgICBjdXJyZW50SW5kZXgsXG4gICAgY3VycmVudEd1ZXNzLFxuICAgIGhhbmRsZUlucHV0LFxuICAgIGd1ZXNzZXMsXG4gICAgZXF1YXRpb24sXG4gICAgc2V0RXF1YXRpb24sXG4gICAgZXJyb3IsXG4gICAgc2V0RXJyb3IsXG4gICAgZ2FtZW92ZXIsXG4gICAgd2luLFxuICAgIGd1ZXNzZWRSZXN1bHQsXG4gICAgc2V0R3Vlc3NlZFJlc3VsdCxcbiAgICBnYW1lb3Zlck1vZGFsLFxuICAgIHNldEdhbWVvdmVyTW9kYWwsXG4gICAgcmVzZXRFdmVyeXRoaW5nLFxuICB9O1xuICByZXR1cm4gKFxuICAgIDxwbGF5ZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt2YWx1ZXN9PntjaGlsZHJlbn08L3BsYXllckNvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG5leHBvcnQgeyB1c2VQbGF5ZXIsIFBsYXllclByb3ZpZGVyIH07XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInBsYXllckNvbnRleHQiLCJ1c2VQbGF5ZXIiLCJQbGF5ZXJQcm92aWRlciIsImNoaWxkcmVuIiwiUk9XU19DT1VOVCIsIkVRVUFUSU9OX0xFTkdUSCIsImN1cnJlbnRHdWVzcyIsInNldEN1cnJlbnRHdWVzcyIsImN1cnJlbnRJbmRleCIsInNldEN1cnJlbnRJbmRleCIsIkFycmF5IiwiZmlsbCIsImd1ZXNzZXMiLCJzZXRHdWVzc2VzIiwiZ2FtZW92ZXIiLCJzZXRHYW1lb3ZlciIsIndpbiIsInNldFdpbiIsImVxdWF0aW9uIiwic2V0RXF1YXRpb24iLCJlcnJvciIsInNldEVycm9yIiwiZ2FtZW92ZXJNb2RhbCIsInNldEdhbWVvdmVyTW9kYWwiLCJndWVzc2VkUmVzdWx0Iiwic2V0R3Vlc3NlZFJlc3VsdCIsImhhbmRsZUlucHV0IiwiZSIsInZhbHVlIiwia2V5IiwiZXFGaWx0ZXIiLCJ0ZW1wX29wZXJhdG9ycyIsInRlc3QiLCJsZW5ndGgiLCJzcGxpdCIsIkxIUyIsIlJIUyIsImZvcm1hdEVxdWF0aW9uIiwiaSIsImluY2x1ZGVzIiwiY2FsY3VsYXRlQXJyYXkiLCJ0ZW1wX2d1ZXNzIiwicHJldiIsInNsaWNlIiwicmVzZXRFdmVyeXRoaW5nIiwiZ2VuZXJhdGVFcXVhdGlvbiIsImVxdWF0aW9uTGVuZ3RoIiwibWF4T3BlcmF0b3JDb3VudCIsIk1hdGgiLCJmbG9vciIsIm1pbk9wZXJhdG9yQ291bnQiLCJwb3NzaWJsZU9wZXJhdG9ycyIsInBvc3NpYmxlTnVtYmVycyIsIm9wZXJhdG9yc1RvVXNlIiwibnVtYmVyc1RvVXNlIiwicmFuZG9tT3BlcmF0b3JDb3VudCIsImdldFJhbmRvbUludCIsInB1c2giLCJzcGxpY2UiLCJMSFNOdW1iZXJDb3VudCIsIkxIU2VxdWF0aW9uTGVuZ3RoIiwiTEhTZXF1YXRpb24iLCJqIiwidW5kZWZpbmVkIiwiZXFTdHJpbmciLCJqb2luIiwiZm9ybWF0dGVkRXFBcnJheSIsInRlbXBfbnVtYmVyIiwidG9TdHJpbmciLCJSSFNBbnN3ZXIiLCJmaW5hbEVxdWF0aW9uIiwiZXhwcmVzc2lvbiIsImNvcHkiLCJyZXBsYWNlIiwibnVtYmVycyIsImZpbHRlciIsIm4iLCJvcGVyYXRvcnMiLCJyZXN1bHQiLCJhcnJheUVxdWF0aW9uIiwiZGl2aWRlIiwidGVtcF9hcnJheSIsImluZGV4T2YiLCJtdWx0aXBseSIsInN1YnN0cmFjdCIsImFkZCIsInBhcnNlSW50IiwibWluIiwibWF4IiwiY2VpbCIsInJhbmRvbSIsInZhbHVlcyIsIlByb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./contexts/PlayerContext.jsx\n");

/***/ })

});